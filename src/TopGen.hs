{-# OPTIONS_GHC -Wall -Wno-orphans #-}

{-# LANGUAGE DataKinds          #-}
{-# LANGUAGE DeriveLift         #-}
{-# LANGUAGE LambdaCase         #-}
{-# LANGUAGE PatternSynonyms    #-}
{-# LANGUAGE StandaloneDeriving #-}
{-# LANGUAGE TypeOperators      #-}
{-# LANGUAGE TemplateHaskell    #-}
{-# LANGUAGE ViewPatterns       #-}
module TopGen
  ( makeTopEntity
  ) where

-- base
import           Prelude

-- template-haskell
import           Language.Haskell.TH
import           Language.Haskell.TH.Syntax

-- clash
import           Clash.NamedTypes            ((:::))
import           Clash.Annotations.TopEntity

--
-- utilities
--

-- matches against `"nam" ::: ty` using (:::) from Clash, but we
-- can't check the type constructor here :(
pattern NamedTy :: Type -> String -> Type
pattern NamedTy con nam <-
  SigT (AppT (AppT con (LitT (StrTyLit nam))) _) _

-- matches a type `a -> b`
pattern ArrowTy :: Type -> Type -> Type
pattern ArrowTy a b = AppT (AppT ArrowT a) b

-- orphans
deriving instance Lift PortName
deriving instance Lift TopEntity

isTupT :: Type -> Bool
isTupT (AppT x _) = isTupT x
isTupT (TupleT _) = True
isTupT _          = False

collectTupT :: Type -> [Type]
collectTupT (AppT (TupleT _) v) = [v]
collectTupT (AppT f v)          = collectTupT f ++ collectTupT v
collectTupT (TupleT _)          = []
collectTupT x                   = [x]

-- | Given an multi-arity function type @f :: a -> b -> c -> ...@, get
-- the final return type.
getReturnTy :: Type -> Q Type
getReturnTy (ArrowTy _ b) = getReturnTy b
getReturnTy b             = return b

-- | Automatically create a @'TopEntity'@ for a given @Name@.
makeTopEntity :: Name -> DecsQ
makeTopEntity n = reify n >>= \case
  VarI nam typ _ -> do
    -- helpers
    let prag t = PragmaD (AnnP (valueAnnotation nam) t)

    -- get a Name for this type operator so we can check it
    -- in the ArrowTy case
    nty <- [t| (:::) |]

    -- examine the arguments
    let examine ty = go ty [] where
          go (ArrowTy (NamedTy con a) b) xs
            | con == nty
            = do { v <- go b xs; return (a:v) }

          go (ArrowTy _ _) _
            = fail $ "makeTopEntity: All types for an autogenerated "
            ++ "top-entity (both input and output) must have a name!"

          go _ xs = return xs

    ins <- map PortName <$> examine typ
    out <- getReturnTy typ >>= \case
      -- single output
      NamedTy con r | con == nty -> return $ PortName r

      -- multi output
      xs@(isTupT -> True) -> do
        let go (NamedTy con r) | con == nty = return (PortName r)
            go _ = fail $ "makeTopEntity: Output tuple must have "
                 ++ "names for all components!"

        PortField mempty <$> mapM go (collectTupT xs)

      -- invalid type
      _ -> fail "makeTopEntity: Invalid return type!"

    -- Return the annotation
    top <- lift $ TopEntity
                    { t_name   = nameBase nam
                    , t_inputs = ins
                    , t_output = out
                    }
    return [prag top]

  -- failure case: we weren't provided with the name of a binder
  _ -> fail "makeTopEntity: invalid Name, must be a top-level binding!"
